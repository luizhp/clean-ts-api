git config --list
git config --system --list
git config --global --list
git config --local --list

//################################################
//setar o VSCODE como editor padrão do git
  1. git config --global core.editor code
  2. git config --global --edit
  3. acrescentar --wait ao final da entrada "editor" => code --wait
//ou setar o GEDIT como editor padrão do git
  git config --global core.editor gedit
//################################################

//Incluir atalhos
1. git config --edit
2. adicionar seção [alias]
3. na seção, incluir a entrada:

   s = !git status -s
       (-s => retorna compacto)

   c = !git add --all && git commit -m
       (add e commita)

   l = !git log --oneline
   l = !git log --pretty=format:'%h %d [%cn, %cr] %s'
   l = !git log --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)<%an>%Creset' --abbrev-commit --date=relative
   l = !git log --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %C(bold blue)<%an> %C(green)%cr%Creset %C(bold)%s' --abbrev-commit --date=relative
   l = !git log --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %C(green)[%cd...%cr]%Creset %C(bold blue)<%an> %n%C(bold)%s%n' --abbrev-commit --date=iso-local
       (git log compacto)

4. gravar e retornar à linha de comando
5. no prompt entrar com um dos seguintes comandos:
   git s (obter git status compacto)
   git c "nome do commit" (git add e git commit)
   git l
-----------
Exemplo .gitconfig

[user]
	name = name
	email = mail@mail.com
[core]
	editor = gedit --wait
[push]
    followTags = true
[alias]
    s = !git status -s
    c = !git add --all && git commit -m
    l = !git log --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %C(green)[%cd...%cr]%Creset %C(bold blue)<%an> %n%C(bold)%s%n' --abbrev-commit --date=iso-local
  lnp = !git --no-pager log --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %C(green)[%cd...%cr]%Creset %C(bold blue)<%an> %n%C(bold)%s%n' --abbrev-commit --date=iso-local
-----------------------
Git Pretty Formats:
https://git-scm.com/docs/pretty-formats


-----------------
Commitar mais alterações ao commit anterior
git add .
git commit --amend --no-edit

ou adicionar arquivo/modificação em commit anterior
(https://stackoverflow.com/a/2719636/5604238)
1. Use "git stash" to store the changes you want to add.
2. Use "git rebase -i HEAD~10" se quero ver 4 commits para trás, coloco HEAD~4, respeitando a quantidade de commits existentes
3. Na linha do commit desejada (a0865...) para editar mudo a palavra pick, no começo da linha, por edit. Não modificar mais nenhuma outra linha
4. Gravar e sair de volta para o shell. Ele trouxe o commit de volta para edição
5. Pop the stash by using "git stash pop"
6. Add your file with "git add <file>"
7. Amend the commit with "git commit --amend --no-edit"
8. Do a "git rebase --continue" which will rewrite the rest of your commits against the new one.
9. Caso precise repita do passo 2 em diante se marcou mais de um commit para edição.

-------------------
git stash

  Aula 15, 19:51 (https://www.udemy.com/course/tdd-com-mango/learn/lecture/17717494#questions)

  Esconde um arquivo incompleto e que pode causar 
    1. git add <<arquivos - completos e incompletos>>
    2. git stash push <<arquivo(s) incompletos>>
       esconde arquivos para poder fazer commit sem bloqueio da validação
    3. git commit ...
    4. git stash list
       lista stashs
    5. git stash pop
       recupera arquivos

-------------------
remover arquivos de commit que foram incluídos sem querer
  https://stackoverflow.com/a/15321456/5604238

Traz de volta à stage todos os arquivos previamente comitados e volta ao commit anterior
  git reset --soft HEAD~1
Then reset the unwanted files in order to leave them out from the commit:
  git reset HEAD path/to/unwanted_file
Now commit again, you can even re-use the same commit message:
  git commit -c ORIG_HEAD --no-edit

-------------------
Seção 8: Bônus - Aula 25 - Criando Tag e fazendo Push para o GitHub

GIT TAGs
  https://git-scm.com/book/en/v2/Git-Basics-Tagging

  Annotated tags
    are those tags meant to be published for other developers, most probably new versions (which should also be signed).
    Not only to see who tagged and when it was tagged, but also why (usually a changelog).

    git tag -a "1.0.0" -m"1.0.0"
  
  Lightweight
    are more appropriate for private use, that means tagging special commits to be able to find them again.
    May it be to review them, check them out to test something or whatever.

    git tag "1.0.0"

  - Push git tags

      . Envia todas tags (Annotated/Lightweight)
          git push origin master --tags
      
      . Push all the refs that would be pushed without this option, and also push annotated tags in refs/tags
        that are missing from the remote but are pointing at commit-ish that are reachable from the refs being pushed.
          git push origin master --follow-tags
        This can also be specified with configuration variable push.followTags
          [push]
             followTags = true

  - Dica sobre modificação de version no arquivo package.json
    . incrementa versão
    . faz commit com "chore: update api version"
    . faz tag
    . faz push
